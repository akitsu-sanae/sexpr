* sexpr: A S-expression library for Rust
  sexpr strives to be the canonical library for reading, manipulating and
  writing S-expressions in Rust.

  The parser is fully featured, performant and can be configured to read almost
  any s-expression variant including "/Standard/", "/Advanced/" and
  "/Canonical/" formats.

  Predefined compatibility configurations exist for a dozen standards and
  protocols including:

  - Standard
  - RFC 2693
  - SMTLIBv2
  - GPG / libgcrypt
  - KiCad
  - R6RS-compatible
  - Guile scheme

  Individual format options can be enabled or disabled, allowing you to parse
  virtually any variant.

# * Overview
#   S-expressions are data structures for representing complex data. They are
#   either primitives ("atoms") or lists of simpler S-expressions. Here is a
#   sample S-expression:

#   ~(snicker "abc" (#03# |YWJj|))~

#   It is a list of length three: 

#   - the octet-string "=snicker="

#   - the octet-string "=abc="

#   - a sub-list containing two elements:
#     - the hexadecimal constant =#03#=
#     - the base-64 constant =|YWJj|= (which is the same as "=abc=")
  
# ** Should I use S-expressions as my serialization format?
#    Despite rapidly shifting technological landscapes and even faster changing
#    attitudes about 'proper' programming. S-expressions, and their many variants,
#    remain ([[http://www-formal.stanford.edu/jmc/recursive/recursive.html][as one of the oldest general encoding formats still in use today]]).

#    In spite of numerous challengers like JSON and XML, S-expressions retain the
#    advantages laid out by early computing and internetworking pioneers:
 
#    - Generality :: S-expressions are good at representing arbitrary data.
#    - Readability :: it is easy for someone to examine and understand the structure of an S-expression.
#    - Economy :: S-expressions represent data compactly.
#    - Tranportability :: S-expressions are easy to transport over communication media (such as email) with unusual encoding rules.
#    - Flexibility :: S-expressions make it relatively simple to modify and extend data structures.
#    - Canonicalization ::  They produce a unique "canonical" form of an S-expression, for digital signature purposes.
#    - Efficiency :: S-expressions should admit in-memory representations that allow efficient processing.   
  
** Parsing S-expression variants
   
*** Included Configuration Options
**** Comments
     Line comments can be enabled when parsing s-expressions by setting
     ~allow_comments = Some(&["#", ";"])~.

     This ignores the rest of the stream until encountering a newline or EOF,
     this does *not* comment out interior s-expressions like proposals like [[http://srfi.schemers.org/srfi-62/srfi-62.html][SRFI
     62]].

**** Keywords
     Many Scheme implementations assign a special meaning to atoms beginning with
     =#:= or =:=, sexpr can parse these as 'keywords' or they can be treated as valid
     starting characters to an ordinary symbol. =(item :keyword value :keyword2 value)=

     You can control this behaviour with ~ParseConfig.allow_keywords = Some(&["#", "#:"])~
   
**** Brackets
     Some Lisp implementations and s-expressions allow square brackets (=[= and
     =]=) to be used as an alternative bracket character.

     These brackets must still themselves remain matched.

     This is controlled with =ParseConfig.square_brackets = true=

**** Radix Specification: 
***** ~#~
      Libgcrypt, GPG and numerous Scheme implementations allow you to enclose a
      hexadecimal string in =#= characters: ~(q #61626364656667#)~

      You can enable this with =enclosed_hex_strings=
    
*****  ~#b~ and ~#x~
      In a similar fashion, =#b= and =#x= are used to specify binary and
      hexadecimal encodings of the number that follows the trailing letter.

      ~((two-hundred-fifty-five #xff)~ would be encoded as =List(Symbol(two-hundred-fifty-five), U64(255))= 
      Similarly, ~(sixteen #b10000))~ would be encoded as =List(Symbol(sixteen), U64(16))=

      You can control if both of these are accepted with the ~radix_escape~ option.

***** Both
      When both of these options are enabled in tandem, sexpr will use the
      following character to determine the variety of radix specification.

***** Neither
      If ~radix_escape~ is false, the initial ~#~ character will be treated as
      an atom.

**** ~|~ (Pipe) Character Behavior 
     Standard decoding treats the | character as a valid starting literal to any
     Atom, although two other options are permitted:

****** /Advanced/-style
       Rivest-style 'advanced' encodings dictate a string between two =|=
       characters be decoded as a stream of u8 (octets) in Base64.

       Use ~ParseConfig.pipe_action = ParsePipeBehavior::Base64Interior~

****** SMTLIBv2
       SMT and SAT solvers using this format use the =|= character to quote it's
       interior, preserving line breaks and other whitespace in a Symbol.

       Use ~ParseConfig.pipe_action = ParsePipeBehavior::QuoteInterior~
